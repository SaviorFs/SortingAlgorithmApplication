4 Sorting Algorithm Application
4.1 Objective:

Implement several sorting algorithms (e.g., quicksort, mergesort, heapsort). After implementing these algo-
rithms, profile their performance with different data sets, identify scenarios where each algorithm performs

best, and develop optimizations for specific use cases.

4.2 Functional Requirements:

1. The application must include implementations of seven sorting algorithms: quicksort, mergesort, heap-
sort, bubble sort, insertion sort, selection sort, and radix sort, allowing for comprehensive comparison.

2. The application must allow users to input unsorted data sets of varying sizes (scaled from 1 KB to 1
GB, (1KB, 10KB, 100KB, 1MB, 10MB, 100MB, 1GB)) into any of the implemented sorting algorithms.
3. One type of input data set should be “Integer” data.
4. One type of input data should be “String” data.
5. One type of input data should be “Object” data, where each object is instantiated from the same base
class and includes three attributes of type “String”, “Integer”, and “Double”.

4.3 Non-Functional Requirements:
1. All test cases must be automated with each test case executed a minimum of 10 times, taking the
average to create high quality data points.
2. Method/Function/Unit profiling, throughput, and scalability characteristics should be gathered, tested,
and optimized.
3. CPU, Memory, and Disk I/O utilization characteristics should be gathered, tested, and optimized.
4. Load and Stress tests should be created, executed, with results visualized.
5. Performance optimization techniques should be created and tested.
